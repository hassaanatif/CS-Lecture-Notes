
                            ============================================================
                             Compilers Lecture 12: Parsing (1): Context-Free Grammars
                            ============================================================


===========
Here's what happens
===========
Your program will be viewed by the scanner as a string of characters. The scanner divides this big string into words or tokens. The syntactic categories 
that the scanner identifies will become the symbols of the alphabet set that the parser deals with. At the parsing level, the alphabet set will consist of 
identifiers, number, = , +, - , *, if , else..
Mathematically:   {identifier, number, = , +, -, *, if , else}

Each one of the above are treated as a single symbol of the alphabet set. There are two levels: There is the scanning level, where we do the microsyntax and
we identify the words of the language. And then there is the parsing level. At the parsing level, these words become individual symbols in that language that
we will be trying to recognize using CONTEXT FREE GRAMMAR. 

============================
Parser calling the scanner
============================
The parser will call the scanner and the scanner will return a part of speech (ident, number, etc) and it will also return the actual lexeme. The parser will
call the GetNextWord() to get the next word and it's syntactic category. 

=============================
Two ways of viewing a scanner
==============================
In theory, it can work both ways (but in practice (i) is the followed one):
i) The scanner can get called one word at a time and then pass it to the scannner. It will return one word at a time.
ii) Scanner can also operate on the entire input and then just pass it as a list to the parser. 

=========================================
Treatment of floating point and integers
=========================================
When we talk about parsing, there will be little advantage in doing both integer and floating point numbers. So we will talking about integers. Because it 
will be the same concept from parsing point of view. From scanning point of view, it is different. 
All that the scanner does is that it identifies a character as a syntactic category and it passes the actual lexeme to the parser and then the parser can 
take care of it. 

=============================
What about number conversion
=============================
In principle, it doesn't belong to either scanning or parsing. But it can be done in either of those.


====================
What is a "Grammar"
====================
It is a set of rules for defining a language that recognizes or that generates a certain language. A formal language is just a set of strings. So grammar 
is a set of rules that generate all the strings that belong to a given language. If that (formal) language is REGULAR then we DO NOT need grammars because 
we can recognize that language using FA or regular expressions. Grammars are more general. And the special kind of grammars that generate Regular languages
are called "Regular Grammars". There is a subset of the CONTEXT FREE GRAMMAR  is the set of regular grammars that recognize regular languages.
Context Free Grammars are also a subset of context-sensitive grammars. Here we focus on those languages that are non regular that cannot be recognized by 
finite automatas or regular expressions. 
EXAMPLE of non regular language: 
                                 L = {a^n b^n | n>=0} 
 
================================
The "4" tuple notion of grammar
================================
G = {V, T, P, S) 
V: set of variables (non-terminals) 
T: set of terminals 
P: set of productions 
S: start variable 
 

==================
More on terminals
==================
Terminals can be viewed as set of strings that can be generated by a grammar. 

===================================================
Convention for writing terminals and non-terminals
===================================================
We write terminals in small letters and non-terminals in large letters. We can also underline terminals. 
 

===============
Derivation tree
=================
The string that gets derived will be present on the leaves of the derivation tree. The ABSTRACT SYNTAX TREE comes from the derivation tree. 

=======================================
Difference b/w AST and Derivation tree
=======================================
The difference between an AST and a parse tree is that in an AST we keep ONLY THE NODES THAT CORRESPOND TO ACTUAL OPERATIONS and we get rid of the nodes
that coresspond to grammatical symbols. You don't care about the symbols in the grammar. You care about nodes that correspond to operations like "add", 
or "multiply" etc that will be translated into actual code. Because we are building AST to generate the code. 


======================
Non ambiguous grammar
======================
If there is a single derivation tree for a given type of grammar then the grammar is said to be non-ambiguous. If there are multiple derivations then it is
ambiguous.

=============================================================
What makes a CONTEXT FREE AS OPPOSED TO CONTEXT SENSITIVE
=============================================================
In a context free grammar, all the variables that appear on the left hand side or whatever appears on the left hand side is an individual (or a single)
variable. If on the left hand side, you have a single variable and terminals then it will be CONTEXT SENSITIVE as well. We're not interested in 
context sensitive grammar in this course because programming languages can be defined in terms of context free grammars. 


============================================================
CFG as an acronym is for something else in compilers course
============================================================
It is for "control flow graph". 


==================================
Leftmost and rightmost derivation
==================================
Usually a string will have a leftmost derivation AND a rightmost derivation. Unless the grammar is very simple, there will always be a leftmost derivation
and a rightmost derivation. But THIS WILL NOTTT make the language ambiguous. A tree doesn't necessarily capture the notion of the distinguishment between
the leftmost and rightmost derivation. So for an umambiguous grammar, the parse tree will be the same for both leftmost and rightmst derivation.

================================
WHY DO WE CARE ABOUT DERIVATION?
================================
Because Parsing is all about finding a derivation for a string. So your program is a string that belongs to that programming language and the parser is 
trying to find a derivation for that. So given the rules and the productions that we will write to define the programming language. The Parser is that 
stage that looks at the rules and the program (that is a string of characters) and it tries to find a derivation for that string. So your program (even 
if it is a million line program) is one big string that should belong to that, that must belong to the language DEFINED BY THE CONTEXT FREE GRAMMAR 
OF THAT PROGRAMMING LANGUAGE

====================================
Constructing AST from Parse Tree
=====================================
After finding the derivation, the parser will construct a derivation tree for that language and then that derivation tree will become the abstract syntax
tree. 

=================================
Parsing as automated derivation
=================================
Parsing is automated derivation. It is a program that does the derivation. So there are specific algorithms for that. When we find derivation on a piece of 
paper, we are doing it by INSPECTION. The problem is that is not feasible to do a derivation through inspection for a program with potentially a million 
lines of code. so we need an algorithm to do this (to automate the derivation. Or to figure out the valid derivation for the string). The compiler will 
also need to figure out if no derivation is possible. If no derivation is possible then the compiler should report a SYNTAX ERROR> 